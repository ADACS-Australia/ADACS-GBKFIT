import glob
import os
import sys
import json
import numpy as np


def read_config_json(job_json):
    config = json.load(open(job_json))
    psf_fwhm_x = config['psf']['fwhm_x']
    psf_fwhm_y = config['psf']['fwhm_y']
    psf_pa = config['psf']['pa']
    step_x = config['dmodel']['step'][0]
    step_y = config['dmodel']['step'][1]

    return config, psf_fwhm_x, psf_fwhm_y, psf_pa, step_x, step_y


def read_result_json(result_json):
    vsys = None
    results = json.load(open(result_json))
    params = results['modes'][0]['parameters']
    for param in params:
        if param['name'] == 'vsys':
            vsys = param['value']

    return vsys, results, params


def cube_to_image(cube):
    """
    Broad assumption about dimensions. This should rather be taken from the header.
    """
    argmax_image = None
    if len(cube.shape) == 3:
        argmax_image = np.zeros((cube.shape[1], cube.shape[2]))
        for i in range(cube.shape[1]):
            for j in range(cube.shape[2]):
                argmax_image[i, j] = np.nanargmax(cube[:, i, j])
    if len(cube.shape) == 4:
        argmax_image = np.zeros((cube.shape[2], cube.shape[3]))
        for i in range(cube.shape[2]):
            for j in range(cube.shape[3]):
                argmax_image[i, j] = np.nanargmax(cube[0, :, i, j])

    return argmax_image


def make_image(job_json, result_json, data_file, mask_file, model_file, residual_file, output_file, is_cube=False):
    """
    Modified version of code provided by George. Not yet tested.
    :param job_json: json file used to launch gbkfit_app_cli
    :param result_json: resulting json file generated by gbkfit_app_cli
    :param data_file: data fits file outputed by gbkfit_app_cli
    :param mask_file: mask fits file outputed by gbkfit_app_cli
    :param model_file: model fits file outputed by gbkfit_app_cli
    :param residual_file: residual fits file outputed by gbkfit_app_cli
    :param output_file: output image file
    :return: nothing.
    """
    import json
    import math
    import numpy as np
    from astropy.io import fits
    import matplotlib as mpl
    mpl.use('Agg')
    from matplotlib import pyplot as plt
    from matplotlib import rc
    from matplotlib import gridspec
    from matplotlib import patches
    from mpl_toolkits.axes_grid1 import inset_locator

    # Set font size for labels and axes ticks (http://matplotlib.org/users/customizing.html)
    rc('font', size=14)
    rc('axes', titlesize=14)
    rc('axes', labelsize=13)

    # Figure constants
    FIG_FILE_DPI = 150
    FIG_PLOT_DPI = 150
    FIG_SIZE_UNIT = 1.0
    FIG_SIZE_X = 9.0
    FIG_SIZE_Y = 3.0

    # Read configuration file. It assumes that it is located in the results-dir.
    config = json.load(open(job_json))
    psf_fwhm_x = config['psf']['fwhm_x']
    psf_fwhm_y = config['psf']['fwhm_y']
    psf_pa = config['psf']['pa']
    step_x = config['dmodel']['step'][0]
    step_y = config['dmodel']['step'][1]

    # Read results file. It assumes that it is located in the results results-dir.
    vsys = None
    results = json.load(open(result_json))
    params = results['modes'][0]['parameters']
    for param in params:
        if param['name'] == 'vsys':
            vsys = param['value']

    # Load data, model, and residual maps
    map_dat = fits.getdata(data_file)
    map_msk = fits.getdata(mask_file)
    map_mdl = fits.getdata(model_file)
    map_res = fits.getdata(residual_file)

    # Crop the unused space around the data.
    # This is an optional step to improve the clarity of the figure.
    # Currently this is tailored for the SAMI data and it is blindly cropping pixels.
    # A better solution would be to use the mask images and decide where to crop.
    # TODO: crop.
    # map_dat = map_dat[5:45, 5:45]
    # map_msk = map_msk[5:45, 5:45]
    # map_mdl = map_mdl[5:45, 5:45]
    # map_res = map_res[5:45, 5:45]

    # Remove velocity offset completely
    map_dat -= vsys
    map_mdl -= vsys

    # Apply mask to model maps
    map_mdl[np.where(map_msk == 0)] = np.NaN

    if is_cube:
        map_dat = cube_to_image(map_dat)
        map_mdl = cube_to_image(map_mdl)
        map_res = cube_to_image(map_res)

    # Calculate absolute min/max
    map_max = np.nanmax(np.fabs(map_mdl)) * 1.05
    map_max = int(math.ceil(map_max / 10.0)) * 10
    map_min = -map_max

    # Create main figure
    fig = plt.figure(figsize=(FIG_SIZE_X, FIG_SIZE_Y), dpi=FIG_PLOT_DPI)

    # Setup grid
    gs = gridspec.GridSpec(1, 4, wspace=0.0, hspace=0.0, height_ratios=[10], width_ratios=[10, 10, 10, 1])

    # Setup axes
    ax00 = fig.add_subplot(gs[0])
    ax01 = fig.add_subplot(gs[1])
    ax02 = fig.add_subplot(gs[2])
    ax03 = fig.add_subplot(gs[3])

    ax03.set_frame_on(False)
    ax03.patch.set_visible(False)
    ax03.get_xaxis().set_ticks([])
    ax03.get_yaxis().set_ticks([])

    ax00.tick_params(labelbottom=False, labelleft=False, labelright=False)
    ax01.tick_params(labelbottom=False, labelleft=False, labelright=False)
    ax02.tick_params(labelbottom=False, labelleft=False, labelright=False)
    ax03.tick_params(labelbottom=False, labelleft=False, labelright=False)

    data_size_x = map_dat.shape[1]
    data_size_y = map_dat.shape[0]

    ax00.set_xticks([0.25 * data_size_x, 0.5 * data_size_x, 0.75 * data_size_x])
    ax01.set_xticks([0.25 * data_size_x, 0.5 * data_size_x, 0.75 * data_size_x])
    ax02.set_xticks([0.25 * data_size_x, 0.5 * data_size_x, 0.75 * data_size_x])

    ax00.set_yticks([0.25 * data_size_y, 0.5 * data_size_y, 0.75 * data_size_y])
    ax01.set_yticks([0.25 * data_size_y, 0.5 * data_size_y, 0.75 * data_size_y])
    ax02.set_yticks([0.25 * data_size_y, 0.5 * data_size_y, 0.75 * data_size_y])

    cmap = 'RdBu_r'
    im00 = ax00.imshow(map_dat, aspect='auto', interpolation='none', cmap=cmap, vmin=map_min, vmax=map_max)
    im01 = ax01.imshow(map_mdl, aspect='auto', interpolation='none', cmap=cmap, vmin=map_min, vmax=map_max)
    im02 = ax02.imshow(map_res, aspect='auto', interpolation='none', cmap=cmap, vmin=map_min, vmax=map_max)

    ax00.invert_yaxis()
    ax01.invert_yaxis()
    ax02.invert_yaxis()

    # Add column titles
    ax00.set_title(r'Data')
    ax01.set_title(r'Model')
    ax02.set_title(r'Residual')

    # Add row titles
#     ax00.set_ylabel('Velocity')

    # Setup color bars
    # Yes, the code is too comples for just a color bar.
    # I was trying to make it look pretty. :)
    cax0 = inset_locator.inset_axes(
        ax03,
        width='100%',
        height='90%',
        loc=5,
        bbox_to_anchor=(0.0, 0.0, 1.0, 1.0),
        bbox_transform=ax03.transAxes,
        borderpad=0)

    fig.colorbar(im01, cax=cax0, orientation='vertical')
    cax0.set_ylabel(r'km~s$^{-1}$')
    cax0.yaxis.set_label_coords(3.4, 0.5)
#     cax0.tick_params()

    # Setup PSF patches
    psf_patch_size_x = psf_fwhm_x / step_x
    psf_patch_size_y = psf_fwhm_y / step_y
    psf_patch_position = (psf_patch_size_x / 2, psf_patch_size_y / 2)
    psf_patch_angle = psf_pa
    psf_patch_0 = patches.Ellipse(psf_patch_position, psf_patch_size_x, psf_patch_size_y, psf_patch_angle,
                                  color='0.50', alpha=0.5)

    ax00.add_artist(psf_patch_0)

    fig.savefig(output_file, bbox_inches='tight', dpi=FIG_FILE_DPI)


if __name__ == "__main__":
    root_path = sys.argv[1]


    def find_file(match):
        return glob.glob(match)[0]


    # make_image(job_json, result_json, data_file, mask_file, model_file, residual_file, output_file):
    # Prepare the parameters
    job_json = os.path.join(root_path, "json_params.json")
    result_json = os.path.join(root_path, "output", "results.json")

    # Iterate over the different types of image
    for i in ['velmap', 'sigmap', 'flxmap', 'flxcube']:
        try:
            # Get the data and mask files for this image
            data_file = find_file(os.path.join("output", "{}_data.fits".format(i)))
            mask_file = find_file(os.path.join("output", "{}_data_mask.fits".format(i)))

            # Iterate over each mode for this image (And get the model data)
            for model_file in glob.glob(os.path.join("output", "mode_*_{}_model.fits".format(i))):
                # Extract the mode from the filename
                mode = model_file.split('_')[1]
                # Get the residual data for this mode
                residual_file = find_file(os.path.join("output", "mode_{}_{}_residual.fits".format(mode, i)))
                # Build the output filename
                output_file = os.path.join("output", "mode_{}_{}.png".format(mode, i))

                # Actually generate the results image now
                make_image(job_json, result_json, data_file, mask_file, model_file, residual_file, output_file, 'cube' in i)
                print("Generated image for {}".format(i))
        except Exception as e:
            print("Could not generate image for {}".format(i))